name: Extract Firmware Content

on:
  workflow_dispatch:
    inputs:
      extraction_mode:
        description: 'What to extract from firmwares'
        required: true
        type: choice
        options:
          - web_only
          - full_extract
        default: 'web_only'
      create_repos:
        description: 'Create a separate repository for each extracted firmware?'
        required: true
        type: boolean
        default: false
      target_owner:
        description: 'GitHub user/org where repos will be created (required if create_repos=true)'
        required: false
        type: string
        default: ''

permissions:
  contents: write

jobs:
  # â”€â”€â”€ Step 1: Download all firmware images â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  download:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: sudo apt-get update -qq && sudo apt-get install -y -qq squashfs-tools unrar-free zip

      - name: Download firmwares
        run: python tools/download_firmwares.py --output-dir "$RUNNER_TEMP/firmwares"

      - name: Upload firmware cache
        uses: actions/upload-artifact@v4
        with:
          name: firmwares-raw
          path: ${{ runner.temp }}/firmwares/
          retention-days: 1

  # â”€â”€â”€ Step 2: Extract each firmware in parallel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  extract:
    needs: download
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        firmware:
          - name: HG8145V5-V500R020C10SPC212
            file: 5611_HG8145V5V500R020C10SPC212.bin
            source: bin
          - name: EG8145V5-V500R022C00SPC340B019
            file: EG8145V5-V500R022C00SPC340B019.bin
            source: bin
          - name: HN8145XR-V500R022C10SPC160
            file: HN8145XRV500R022C10SPC160.1.bin
            source: bin
          - name: HG8145C-V5R019C00S105
            file: 8145C-V5R019C00S105-EN-BLUE.bin
            source: rar
          - name: HG8245C-8145C-BLUE-R019-xpon
            file: 8245c-8145c-BLUE-R019-EN-xpon.bin
            source: rar
          - name: HG8145C_17120_ENG
            file: HG8145C_17120_ENG.bin
            source: rar
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install dependencies
        run: sudo apt-get update -qq && sudo apt-get install -y -qq squashfs-tools unrar-free zip

      - name: Download firmware cache
        uses: actions/download-artifact@v4
        with:
          name: firmwares-raw
          path: ${{ runner.temp }}/firmwares

      - name: Extract RAR contents (if needed)
        if: matrix.firmware.source == 'rar'
        run: |
          cd "$RUNNER_TEMP/firmwares"
          if [ -f HG8245C.rar ]; then
            unrar x -o+ HG8245C.rar .
          fi

      - name: Extract firmware rootfs
        run: |
          set -e
          mkdir -p "$RUNNER_TEMP/firmware_extract/${{ matrix.firmware.name }}"

          python3 << 'PYEOF'
          import struct, os, shutil, subprocess, sys, gzip, io, tarfile

          def find_squashfs(data):
              results = {}
              for magic in [b'hsqs', b'sqsh']:
                  pos = 0
                  while True:
                      idx = data.find(magic, pos)
                      if idx == -1:
                          break
                      if idx + 96 <= len(data):
                          inode_count = struct.unpack_from('<I', data, idx + 4)[0]
                          bytes_used = struct.unpack_from('<Q', data, idx + 40)[0]
                          if inode_count > 10 and bytes_used > 100000 and bytes_used <= len(data) - idx:
                              if idx not in results:
                                  results[idx] = (idx, bytes_used, inode_count)
                      pos = idx + 4
              return sorted(results.values(), key=lambda x: x[1], reverse=True)

          def extract_tar_gz_archives(data, out_dir):
              archives_dir = os.path.join(out_dir, "archives")
              found = 0
              gz_idx = 0
              pos = 0
              checked_ends = []
              while True:
                  idx = data.find(b'\x1f\x8b\x08', pos)
                  if idx == -1:
                      break
                  if not any(s <= idx < e for s, e in checked_ends):
                      is_tar = False
                      try:
                          quick = io.BytesIO(data[idx:idx + 1048576])
                          with gzip.GzipFile(fileobj=quick) as gz:
                              hdr = gz.read(512)
                          is_tar = (len(hdr) >= 262 and
                                    hdr[257:262] in (b'ustar', b'ustar\x00', b'ustar '))
                      except Exception:
                          pass
                      if is_tar:
                          try:
                              win = min(64 * 1024 * 1024, len(data) - idx)
                              buf = io.BytesIO(data[idx:idx + win])
                              with tarfile.open(fileobj=buf, mode='r:gz') as tf:
                                  members = tf.getmembers()
                                  if members:
                                      os.makedirs(archives_dir, exist_ok=True)
                                      label = f"tgz_{gz_idx:02d}_0x{idx:08x}"
                                      dest = os.path.join(archives_dir, label)
                                      os.makedirs(dest, exist_ok=True)
                                      tf.extractall(dest, members=members, filter='data')
                                      gz_size = buf.tell()
                                      checked_ends.append((idx, idx + gz_size))
                                      print(f"  tar.gz 0x{idx:08x}: {len(members)} files -> archives/{label}/")
                                      gz_idx += 1
                                      found += 1
                          except Exception:
                              pass
                  pos = idx + 3
              return found

          def extract_raw_tar_archives(data, out_dir):
              archives_dir = os.path.join(out_dir, "archives")
              found = 0
              tar_idx = 0
              seen = set()
              pos = 0
              while True:
                  idx = data.find(b'ustar', pos)
                  if idx == -1:
                      break
                  bs = idx - 257
                  if bs >= 0 and bs % 512 == 0 and bs not in seen:
                      if data[bs + 257:bs + 262] in (b'ustar', b'ustar\x00', b'ustar '):
                          try:
                              buf = io.BytesIO(data[bs:bs + 32 * 1024 * 1024])
                              with tarfile.open(fileobj=buf, mode='r:') as tf:
                                  members = tf.getmembers()
                                  if len(members) > 2:
                                      os.makedirs(archives_dir, exist_ok=True)
                                      label = f"tar_{tar_idx:02d}_0x{bs:08x}"
                                      dest = os.path.join(archives_dir, label)
                                      os.makedirs(dest, exist_ok=True)
                                      tf.extractall(dest, members=members, filter='data')
                                      print(f"  tar 0x{bs:08x}: {len(members)} files -> archives/{label}/")
                                      seen.add(bs)
                                      tar_idx += 1
                                      found += 1
                          except Exception:
                              pass
                  pos = idx + 5
              return found

          _runner_temp = os.environ["RUNNER_TEMP"]
          fw_file = _runner_temp + "/firmwares/" + "${{ matrix.firmware.file }}"
          name = "${{ matrix.firmware.name }}"
          mode = "${{ inputs.extraction_mode }}"
          out_dir = _runner_temp + "/firmware_extract/" + name

          print(f"Processing {name} (mode={mode})")
          with open(fw_file, 'rb') as f:
              data = f.read()

          sqfs_list = find_squashfs(data)
          if not sqfs_list:
              print("No SquashFS found!")
              sys.exit(1)

          print(f"Found {len(sqfs_list)} SquashFS image(s)")
          os.makedirs(out_dir, exist_ok=True)

          rootfs_dir = None
          for i, (offset, size, inodes) in enumerate(sqfs_list):
              label = f"sqfs_{i:02d}_0x{offset:08x}"
              print(f"  [{i}] SquashFS at 0x{offset:08x}, {size:,} bytes, {inodes} inodes")
              sqfs_path = f"{_runner_temp}/{label}.sqfs"
              with open(sqfs_path, 'wb') as f:
                  f.write(data[offset:offset + size])
              rootfs = f"{_runner_temp}/rootfs_{i}"
              os.makedirs(rootfs, exist_ok=True)
              subprocess.run(["sudo", "unsquashfs", "-f", "-d", rootfs,
                              "-no-xattrs", "-ignore-errors", sqfs_path], check=False)
              subprocess.run(["sudo", "chmod", "-R", "a+rX", rootfs], check=False)
              if i == 0:
                  rootfs_dir = rootfs
              else:
                  extra_out = os.path.join(out_dir, f"rootfs_{i}")
                  subprocess.run(["sudo", "cp", "-ra", rootfs, extra_out], check=False)
                  subprocess.run(["sudo", "chown", "-R",
                                  f"{os.getuid()}:{os.getgid()}", extra_out], check=False)
                  n = sum(1 for _, _, fs in os.walk(extra_out) for _ in fs)
                  print(f"    -> rootfs_{i}/: {n} files")

          dirs_to_copy = {"web": "html", "configs": "etc/wap"}
          if mode == "full_extract":
              dirs_to_copy.update({"bin": "bin", "sbin": "sbin", "lib": "lib", "etc": "etc"})

          total = 0
          for dest_name, src_rel in dirs_to_copy.items():
              src = os.path.join(rootfs_dir, src_rel)
              if os.path.isdir(src):
                  dst = os.path.join(out_dir, dest_name)
                  subprocess.run(["sudo", "cp", "-ra", src, dst], check=False)
                  subprocess.run(["sudo", "chown", "-R",
                                  f"{os.getuid()}:{os.getgid()}", dst], check=False)
                  n = sum(1 for _, _, fs in os.walk(dst) for _ in fs)
                  print(f"  {dest_name}: {n} files")
                  total += n

          gz_count = extract_tar_gz_archives(data, out_dir)
          tar_count = extract_raw_tar_archives(data, out_dir)
          print(f"  archives: {gz_count} tar.gz + {tar_count} raw tar extracted")
          print(f"Total: {total} rootfs files + {gz_count + tar_count} archive(s) extracted")
          PYEOF

      - name: Create ZIP for release
        run: |
          cd $EXTRACT_DIR
          zip -r $RUNNER_TEMP/${{ matrix.firmware.name }}.zip ${{ matrix.firmware.name }}/

      - name: Upload extracted content as artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.firmware.name }}
          path: ${{ env.EXTRACT_DIR }}/${{ matrix.firmware.name }}/
          retention-days: 90

      - name: Upload ZIP as artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.firmware.name }}-zip
          path: ${{ runner.temp }}/${{ matrix.firmware.name }}.zip
          retention-days: 90

  # â”€â”€â”€ Step 3: Create release with all ZIPs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  release:
    needs: extract
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Download all ZIP artifacts
        uses: actions/download-artifact@v4
        with:
          path: ${{ runner.temp }}/artifacts
          pattern: '*-zip'
          merge-multiple: true

      - name: Collect ZIPs
        run: |
          mkdir -p $RUNNER_TEMP/release_assets
          find $RUNNER_TEMP/artifacts -name '*.zip' -exec cp {} $RUNNER_TEMP/release_assets/ \;
          echo "Release assets:"
          ls -lh $RUNNER_TEMP/release_assets/

      - name: Create release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: firmware-extract-${{ github.run_number }}
          name: "Firmware Extract #${{ github.run_number }} (${{ inputs.extraction_mode }})"
          body: |
            ## Extracted Firmware Content

            **Mode:** `${{ inputs.extraction_mode }}`

            Each ZIP contains the extracted content from one firmware image:
            - `web/` â€” Router web interface (HTML/JS/CSS/ASP pages)
            - `configs/` â€” Device configurations from `/etc/wap/`
            ${{ inputs.extraction_mode == 'full_extract' && '- `bin/` `sbin/` `lib/` `etc/` â€” Full rootfs content' || '' }}

            ### Firmwares
            | Firmware | Model | Version |
            |----------|-------|---------|
            | HG8145V5-V500R020C10SPC212 | HG8145V5 | V500R020C10SPC212 |
            | EG8145V5-V500R022C00SPC340B019 | EG8145V5 | V500R022C00SPC340 |
            | HN8145XR-V500R022C10SPC160 | HN8145XR | V500R022C10SPC160 |
            | HG8145C-V5R019C00S105 | HG8145C | V5R019C00S105 |
            | HG8245C-8145C-BLUE-R019-xpon | HG8245C | R019 |
            | HG8145C_17120_ENG | HG8145C | 17120 |
          files: ${{ runner.temp }}/release_assets/*.zip
          draft: false
          prerelease: false

  # â”€â”€â”€ Step 4: Create repos for each firmware (optional) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  create-repos:
    if: inputs.create_repos == true && inputs.target_owner != ''
    needs: extract
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 1
      matrix:
        firmware:
          - HG8145V5-V500R020C10SPC212
          - EG8145V5-V500R022C00SPC340B019
          - HN8145XR-V500R022C10SPC160
          - HG8145C-V5R019C00S105
          - HG8245C-8145C-BLUE-R019-xpon
          - HG8145C_17120_ENG
    steps:
      - name: Checkout source repo
        uses: actions/checkout@v4
        with:
          path: source_repo

      - name: Download firmware artifact
        uses: actions/download-artifact@v4
        with:
          name: ${{ matrix.firmware }}
          path: ${{ runner.temp }}/content/${{ matrix.firmware }}

      - name: Create repo and push content
        env:
          GH_TOKEN: ${{ secrets.ONT }}
          TARGET_OWNER: ${{ inputs.target_owner }}
          FW_NAME: ${{ matrix.firmware }}
        run: |
          set -e

          if [ -z "$GH_TOKEN" ]; then
            echo "::error::Secret 'ONT' is not configured. Add a GitHub PAT with repo scope."
            exit 1
          fi

          BASE_NAME="firmware-${FW_NAME}"
          REPO_NAME="$BASE_NAME"
          COUNTER=1

          # Find an available repo name; append _1, _2, â€¦ if needed
          while true; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
              -H "Authorization: token ${GH_TOKEN}" \
              "https://api.github.com/repos/${TARGET_OWNER}/${REPO_NAME}")
            if [ "$HTTP_CODE" != "200" ]; then
              break
            fi
            echo "Repository ${REPO_NAME} already exists, trying ${BASE_NAME}_${COUNTER}..."
            REPO_NAME="${BASE_NAME}_${COUNTER}"
            COUNTER=$((COUNTER + 1))
          done

          echo "=== Creating ${TARGET_OWNER}/${REPO_NAME} ==="

          # Detect if target is org or user
          OWNER_TYPE=$(curl -s \
            -H "Authorization: token ${GH_TOKEN}" \
            "https://api.github.com/users/${TARGET_OWNER}" \
            | python3 -c "import json,sys; print(json.load(sys.stdin).get('type','User'))")

          if [ "$OWNER_TYPE" = "Organization" ]; then
            API_URL="https://api.github.com/orgs/${TARGET_OWNER}/repos"
          else
            API_URL="https://api.github.com/user/repos"
          fi

          curl -s -X POST \
            -H "Authorization: token ${GH_TOKEN}" \
            -H "Content-Type: application/json" \
            "$API_URL" \
            -d "{
              \"name\": \"${REPO_NAME}\",
              \"description\": \"Extracted content from Huawei ${FW_NAME} firmware\",
              \"private\": false,
              \"auto_init\": true
            }"
          echo "Waiting for repo to be ready..."
          sleep 5

          # Clone and push
          cd $RUNNER_TEMP
          git clone "https://x-access-token:${GH_TOKEN}@github.com/${TARGET_OWNER}/${REPO_NAME}.git" repo_work || {
            mkdir repo_work && cd repo_work && git init && \
            git remote add origin "https://x-access-token:${GH_TOKEN}@github.com/${TARGET_OWNER}/${REPO_NAME}.git"
          }
          cd $RUNNER_TEMP/repo_work

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Copy ALL extracted firmware content (including hidden files, using /. source)
          if [ -d "$RUNNER_TEMP/content/${FW_NAME}" ]; then
            cp -ra "$RUNNER_TEMP/content/${FW_NAME}/." .
          else
            echo "::warning::No extracted content found for ${FW_NAME}"
          fi

          # Replace any auto-generated .gitignore with one that excludes only real
          # temp/work files and keeps all firmware content
          printf '*.tmp\n*.log\n*.pid\n*.swp\n*.swo\n*~\n.DS_Store\nThumbs.db\n__pycache__/\n*.pyc\n*.pyo\n' > .gitignore

          # Generate README.md for this firmware repo
          cat > README.md << READMEEOF
          # ${FW_NAME}

          Extracted firmware content from Huawei **${FW_NAME}**.

          ## Contents

          | Directory | Description |
          |-----------|-------------|
          | \`web/\` | Router web interface (HTML/JS/CSS/ASP pages) |
          | \`configs/\` | Device configurations from \`/etc/wap/\` |
          | \`bin/\` | System binaries (if full extraction) |
          | \`lib/\` | Shared libraries (if full extraction) |
          | \`etc/\` | System configuration (if full extraction) |

          ## Source

          Extracted using [HuaweiFirmwareTool](https://github.com/Uaemextop/HuaweiFirmwareTool).

          ## Firmware Analysis

          This repository includes a Copilot agent (\`.github/agents/firmware-analyst.agent.md\`) that understands how to:
          - Decrypt \`hw_ctree.xml\` configuration files
          - Extract SquashFS rootfs from HWNP firmware images
          - Analyze AES-256-CBC encrypted private keys
          - Parse firmware partition structures

          See \`.github/copilot-instructions.md\` for details.
          READMEEOF

          # Copy .github files and tools from source repo
          mkdir -p .github/agents .github/workflows
          SOURCE_REPO="${GITHUB_WORKSPACE}/source_repo"
          cp "${SOURCE_REPO}/.github/copilot-instructions.md" .github/copilot-instructions.md
          cp "${SOURCE_REPO}/.github/agents/firmware-analyst.agent.md" .github/agents/firmware-analyst.agent.md
          cp "${SOURCE_REPO}/.github/workflows/copilot-setup-steps.yml" .github/workflows/copilot-setup-steps.yml
          cp -r "${SOURCE_REPO}/tools" ./tools

          # Commit and push
          git add -A
          git diff --cached --quiet && echo "No changes to commit" || {
            git commit -m "Add extracted ${FW_NAME} content with Copilot agent and instructions"
            DEFAULT_BRANCH=$(git remote show origin 2>/dev/null | grep 'HEAD branch' | awk '{print $NF}')
            DEFAULT_BRANCH=${DEFAULT_BRANCH:-main}
            git push origin "${DEFAULT_BRANCH}" 2>&1 || echo "::warning::Push failed for ${REPO_NAME}"
          }

          echo "âœ“ ${TARGET_OWNER}/${REPO_NAME} ready"
          rm -rf $RUNNER_TEMP/repo_work

          REPO_URL="https://github.com/${TARGET_OWNER}/${REPO_NAME}"
          echo "${REPO_URL}" > $RUNNER_TEMP/${FW_NAME}-url.txt

          echo "=== Disabling Copilot content exclusions (firewall) for ${TARGET_OWNER}/${REPO_NAME} ==="
          COPILOT_HTTP=$(curl -s -o $RUNNER_TEMP/copilot_resp.json -w "%{http_code}" \
            -X PUT \
            -H "Authorization: token ${GH_TOKEN}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Content-Type: application/json" \
            "https://api.github.com/repos/${TARGET_OWNER}/${REPO_NAME}/copilot/content_exclusion" \
            -d '{"paths":[]}')
          if [ "$COPILOT_HTTP" = "200" ] || [ "$COPILOT_HTTP" = "201" ]; then
            echo "âœ“ Copilot content exclusions cleared for ${REPO_NAME}"
          else
            echo "::warning::Could not update Copilot settings for ${REPO_NAME} (HTTP ${COPILOT_HTTP}). Requires GitHub Copilot Business/Enterprise."
            cat $RUNNER_TEMP/copilot_resp.json || true
          fi

      - name: Upload repo URL artifact
        uses: actions/upload-artifact@v4
        with:
          name: repo-url-${{ matrix.firmware }}
          path: ${{ runner.temp }}/${{ matrix.firmware }}-url.txt

  # â”€â”€â”€ Step 5: Dashboard â€” show all created repo URLs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  dashboard:
    if: inputs.create_repos == true && inputs.target_owner != ''
    needs: create-repos
    runs-on: ubuntu-latest
    steps:
      - name: Download all repo URL artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: repo-url-*
          path: ${{ runner.temp }}/repo_urls
          merge-multiple: true

      - name: Write step summary dashboard
        run: |
          echo "## ðŸ—‚ï¸ Created Firmware Repositories" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Firmware | Repository URL |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|----------------|" >> $GITHUB_STEP_SUMMARY
          for f in $RUNNER_TEMP/repo_urls/*-url.txt; do
            [ -f "$f" ] || continue
            FW=$(basename "$f" -url.txt)
            URL=$(cat "$f")
            echo "| \`${FW}\` | [${URL}](${URL}) |" >> $GITHUB_STEP_SUMMARY
          done
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "> Copilot content exclusions (firewall) were cleared on each repository via the GitHub API." >> $GITHUB_STEP_SUMMARY
