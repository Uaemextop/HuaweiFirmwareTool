# Full Firmware Decompilation Report
> Generated by `tools/fw_full_decompile.py` — Huawei HG8145V5 Telmex R019C10SPC310B002

---

## 1. Summary of Decompiled Binaries

| Binary | Size | Exports | PLT Imports | Purpose |
|--------|------|---------|-------------|---------|
| `aescrypt2` | 17,920 B | 13 | 44 | AES encrypt/decrypt; key from KMC chain |
| `cfgtool` | 14,104 B | 28 | 33 | Config XML manipulation |
| `libhw_ssp_basic.so` | 751,728 B | 2,134 | 1,592 | KMC API, PBKDF2, AES wrappers |
| `libhw_ssp_ssl.so` | 13,188 B | 34 | 42 | SSL wrapper; private-key loading |
| `libhw_swm_dll.so` | 279,508 B | 541 | 718 | ctree encrypt/decrypt, eFuse load |
| `libpolarssl.so` | 510,940 B | 908 | 618 | PolarSSL/mbedTLS full crypto |
| `libwlan_aes_crypto.so` | 4,964 B | 9 | 8 | WLAN AES-128-CBC wrapper |
| `libsmp_api.so` | 245,076 B | 543 | 575 | SMP/DM API; root pub-key access |
| `libhw_smp_dm_pdt.so` | 229,904 B | 479 | 538 | eFuse info RPC |
| `athtestcmd` | 78,780 B | 70 | 60 | Atheros WiFi test; efusedump/efusewrite |

---

## 2. Key Derivation Architecture

```
Device eFuse (hardware OTP)
    │
    ▼
HW_SWM_LoadEfuse → HW_SWM_GetEfuseBuffer → efuseData / efuseSig / efusePubkey
    │                     (libhw_swm_dll.so @ 0x375f4)
    ▼
KMC Domain Key (kmc_store_A / kmc_store_B  OR  derived from eFuse at first boot)
    │
    ▼  HW_KMC_GetAppointKey (libhw_ssp_basic.so @ 0x9b108)
    ▼  HW_KMC_GetActiveKey  (libhw_ssp_basic.so @ 0x9b000)
    │
    ├──► AES-256-CBC key for hw_ctree.xml (via aescrypt2 / OS_AescryptDecrypt)
    │       Hardcoded fallback: "Df7!ui%s9(lmV1L8" (when KMC unavailable)
    │
    └──► PBKDF2-SHA256 passphrase for prvt.key (via mbedtls_pk_parse_keyfile)
            HW_OS_GetSaltStrForPbkdf2 (libhw_ssp_basic.so @ 0x2f0f4)
            HW_OS_PBKDF2_SHA256       (libhw_ssp_basic.so @ 0x2f3e8)
```

---

## 3. Known Keys / Passphrases

| Key | Value | Location | Usage |
|-----|-------|----------|-------|
| AES fallback | `Df7!ui%s9(lmV1L8` | libhw_ssp_basic.so:0xa0fbf, libhw_swm_dll.so:0x37f68, aescrypt2:0x3117 | hw_ctree.xml AES-256-CBC (fallback when KMC unavailable) |
| PolarSSL test RSA | `PolarSSLTest` | libpolarssl.so:0x6db4c | 2048-bit RSA key embedded in libpolarssl.so |
| PolarSSL test EC | `PolarSSLTest` | libpolarssl.so:0x6efd4 | EC secp256r1 key embedded in libpolarssl.so |

### Decrypted Test Keys (from libpolarssl.so)
- `keys/extracted/*_libpolarssl_0x6db60_RSA_PRIVATE_KEY_decrypted_PolarSSLTest.pem` — 2048-bit RSA
- `keys/extracted/*_libpolarssl_0x6efe8_EC_PRIVATE_KEY_decrypted_PolarSSLTest.pem` — EC P-256

### NAND Dump Keys (from DS35Q1GA NAND dump)
- `keys/nand_encrypted_key_3_vol9_0x7a30d1.decrypted.pem` — decrypted with `PolarSSLTest`
- `keys/nand_encrypted_key_10_vol9_0x1b3e0d1.decrypted.pem` — decrypted with `PolarSSLTest`

---

## 4. prvt.key Encryption Chain (NOT crackable by static analysis)

```
prvt.key header: AES-256-CBC, IV=7EC546FB34CA7CD5599763D8D9AE6AC9
MD5: 0de20c81fc6cf1d0d3607a1bd600f935 (identical across all V500 firmwares)

Passphrase derivation (DYNAMIC — device-specific):
1. HW_KMC_GetAppointKey(domain_id=0x21a) → 32-byte work key
2. HW_OS_GetSaltStrForPbkdf2(device_sn) → 32-byte salt  
3. HW_OS_PBKDF2_SHA256(work_key, salt, iterations, 32) → passphrase bytes
4. mbedtls_pk_parse_keyfile("/etc/wap/prvt.key", passphrase)

The work key comes from kmc_store_A/B which is encrypted with the device eFuse root key.
→ Without the physical device's eFuse, prvt.key CANNOT be decrypted.
```

---

## 5. eFuse Analysis (from NAND dump + libhw_swm_dll.so)

### Key eFuse Functions (libhw_swm_dll.so)
| Function | VAddr | Description |
|----------|-------|-------------|
| `HW_SWM_GetEfuseBuffer` | 0x3736c | Read raw eFuse data buffer |
| `HW_SWM_LoadEfuse` | 0x375f4 | Initialize eFuse subsystem |
| `HW_SWM_Deal_Efuse` | 0x37408 | Process eFuse data |
| `HW_SWM_EfuseSigCheckCore` | 0x36ea4+ | Verify eFuse signature |
| `HW_SWM_CheckEfuseSig` | — | Check eFuse sig integrity |
| `HW_DM_GetRootPubKeyInfo` | 0x23838 | Get root CA pub key from eFuse |
| `HW_DM_GetRootPubKeyFile` | 0x23a04 | Get root pub key file path |

### eFuse Data Fields (strings from libhw_swm_dll.so)
- `efuseData` — raw eFuse read buffer
- `efuseSig` — eFuse signature (RSA-4096 signed by SoC root key)
- `efusePubkey` — device-specific public key stored in eFuse OTP
- `hw_swm_efuse` — eFuse management module identifier

### NAND Dump eFuse chain (from `tools/nand_dump_analyze.py`)
- Volume `flash_config` (256KB): Board config, serial number, eFuse metadata
- Volume `allsystemA`: V500R019C20SPC162B920 Linux-3.10.53-HULK2
- Volume `allsystemB`: V500R020C10SPC212B465 Linux-4.4.219
- 22 X.509 certificates, 8 encrypted keys, 1 plain key found in dump

---

## 6. Decompiled Output Files

```
decompiled/
├── DECOMPILE_FULL_REPORT.md          ← This file
├── DECOMPILE_REPORT.md               ← fw_full_decompile.py output
├── aescrypt2/
│   ├── full_disasm.asm               ← 1,719 ARM instructions annotated
│   ├── exports.txt / imports.txt
│   └── key_strings.txt
├── cfgtool/
│   ├── full_disasm.asm
│   └── exports.txt
├── libhw_ssp_basic/
│   ├── full_disasm.asm               ← 390 ARM instructions
│   ├── HW_KMC_GetAppointKey.asm      ← KMC key retrieval
│   ├── HW_KMC_GetActiveKey.asm
│   ├── HW_OS_GetSaltStrForPbkdf2.asm
│   ├── HW_OS_PBKDF2_SHA256.asm       ← PBKDF2 implementation
│   ├── HW_AES_GetCBCKey.asm
│   └── key_strings.txt               ← 339 key-related strings
├── libhw_ssp_ssl/
│   ├── full_disasm.asm
│   └── key_functions.asm             ← HW_SSL_LoadCertFile decompiled
├── libhw_swm_dll/
│   ├── full_disasm.asm
│   ├── HW_SWM_GetEfuseBuffer.asm     ← eFuse buffer read
│   ├── HW_SWM_LoadEfuse.asm          ← eFuse load/init
│   ├── HW_SWM_Deal_Efuse.asm         ← eFuse processing
│   ├── efuse_key_functions.asm       ← All eFuse functions
│   └── efuse_strings.txt
├── libpolarssl/
│   ├── full_disasm.asm               ← 12,575 ARM instructions
│   ├── polarssl_set_pub_prv_to_conf.asm
│   ├── mbedtls_pk_parse_keyfile.asm  ← PEM key loading path
│   ├── mbedtls_pk_parse_key.asm
│   └── polarssl_pem_read_buffer.asm  ← PEM passphrase handling
├── libsmp_api/
│   ├── HW_DM_GetRootPubKeyInfo.asm   ← Root pub key from eFuse
│   ├── HW_DM_GetRootPubKeyFile.asm
│   ├── HW_DM_GetEncryptedKey.asm
│   └── efuse_key_functions.asm
├── libhw_smp_dm_pdt/
│   ├── HW_DM_RPC_GetEfuseInfo.asm    ← eFuse info RPC
│   ├── HW_DM_RPC_SetEfuseLoad.asm
│   └── efuse_key_functions.asm
├── athtestcmd/
│   ├── full_disasm.asm
│   └── efuse_strings.txt             ← efusedump/efusewrite commands
└── libwlan_aes_crypto/
    └── full_disasm.asm               ← WLAN_AES_Cbc_128_Encrypt/Decrypt
```

---

## 7. How to Run Full Decompilation

```bash
# Extract firmware first
python3 tools/fw_extract.py firmware/HG8145V5_Telmex.bin

# Full decompilation of all binaries
python3 tools/fw_full_decompile.py --rootfs /tmp/telmex_rootfs --out decompiled

# eFuse dump analysis (requires NAND dump)  
python3 tools/nand_dump_analyze.py

# Deep firmware analysis
python3 tools/fw_deep_analysis.py
```

---

## 8. Conclusion

The private key encryption chain (`prvt.key`, `plugprvt.key`) uses:
1. **KMC domain key** → loaded from `kmc_store_A/B` which is encrypted with eFuse OTP
2. **PBKDF2-SHA256** → derives passphrase from (KMC key + device serial)
3. **mbedTLS** → decrypts the PEM with the derived passphrase

**This means the private keys are DEVICE-BOUND and cannot be decrypted without:**
- The physical device (to read eFuse), OR
- Extracting `kmc_store_A/B` from a running device's `/mnt/jffs2/`

**What CAN be decrypted statically:**
- `hw_ctree.xml` using fallback key `Df7!ui%s9(lmV1L8` (only on devices without KMC store)  
- Test keys embedded in `libpolarssl.so` using passphrase `PolarSSLTest`
- NAND dump keys (2 found) using `PolarSSLTest`
