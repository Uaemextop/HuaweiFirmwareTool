/*
 * decrypt_boardinfo.c  â€“  Decrypt hw_boardinfo file
 *
 * Decompiled from: /bin/decrypt_boardinfo (5404 bytes, ARM32, V500R022)
 * Getopt string: "s:d:" (from .rodata at 0xb70)
 * Imports: DM_DecryptBoardInfo (from libhw_smp_dm_pdt.so), getopt, optarg
 *
 * Original: Takes encrypted hw_boardinfo from flash, decrypts using
 * DM_DecryptBoardInfo which uses AES-128-CBC with device-specific key.
 *
 * The hw_boardinfo file format:
 *   Encrypted:  16-byte header + AES-128-CBC encrypted data
 *   Plaintext:  "obj.FieldName = \"Value\" ;" per line
 *
 * Standalone: Implements DM_DecryptBoardInfo using mbedTLS AES,
 * with the default key from firmware analysis.
 *
 * Usage: decrypt_boardinfo -s <encrypted_file> -d <output_file>
 *
 * Build: cc -o decrypt_boardinfo decrypt_boardinfo.c -lmbedcrypto
 *   or:  cc -o decrypt_boardinfo decrypt_boardinfo.c  (uses builtin AES)
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>
#include <getopt.h>

/*
 * Default boardinfo encryption key (from DM_DecryptBoardInfo analysis).
 * This is the fallback key used when no device-specific key is available.
 * The key "Df7!ui%s9(lmV1L8" is from setboardinfo.c .rodata (0x261b).
 */
static const uint8_t default_key[16] = {
    'D','f','7','!','u','i','%','s','9','(','l','m','V','1','L','8'
};

/* Minimal AES-128-CBC implementation (standalone, no external deps) */

/* AES S-box */
static const uint8_t aes_sbox[256] = {
    0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
    0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
    0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
    0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
    0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
    0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
    0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
    0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
    0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
    0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
    0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
    0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
    0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
    0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
    0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
    0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
};

/* AES inverse S-box */
static const uint8_t aes_inv_sbox[256] = {
    0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,
    0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,
    0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,
    0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,
    0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,
    0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,
    0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,
    0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,
    0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,
    0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,
    0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,
    0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,
    0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,
    0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,
    0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,
    0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d
};

static const uint8_t rcon[10] = {
    0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36
};

static uint8_t xtime(uint8_t x) { return (uint8_t)((x<<1) ^ (((x>>7) & 1) * 0x1b)); }

static void aes128_key_expansion(const uint8_t key[16], uint8_t rkeys[176])
{
    int i;
    uint8_t temp[4];
    memcpy(rkeys, key, 16);
    for (i = 4; i < 44; i++) {
        memcpy(temp, rkeys + (i-1)*4, 4);
        if (i % 4 == 0) {
            uint8_t t = temp[0];
            temp[0] = aes_sbox[temp[1]] ^ rcon[i/4 - 1];
            temp[1] = aes_sbox[temp[2]];
            temp[2] = aes_sbox[temp[3]];
            temp[3] = aes_sbox[t];
        }
        rkeys[i*4+0] = rkeys[(i-4)*4+0] ^ temp[0];
        rkeys[i*4+1] = rkeys[(i-4)*4+1] ^ temp[1];
        rkeys[i*4+2] = rkeys[(i-4)*4+2] ^ temp[2];
        rkeys[i*4+3] = rkeys[(i-4)*4+3] ^ temp[3];
    }
}

static void aes128_decrypt_block(const uint8_t rkeys[176], const uint8_t in[16], uint8_t out[16])
{
    uint8_t s[16];
    int i, r;
    memcpy(s, in, 16);

    /* AddRoundKey (round 10) */
    for (i = 0; i < 16; i++) s[i] ^= rkeys[160 + i];

    for (r = 9; r >= 1; r--) {
        /* InvShiftRows */
        uint8_t t;
        t = s[13]; s[13] = s[9]; s[9] = s[5]; s[5] = s[1]; s[1] = t;
        t = s[10]; s[10] = s[2]; s[2] = t;
        t = s[14]; s[14] = s[6]; s[6] = t;
        t = s[3]; s[3] = s[7]; s[7] = s[11]; s[11] = s[15]; s[15] = t;

        /* InvSubBytes */
        for (i = 0; i < 16; i++) s[i] = aes_inv_sbox[s[i]];

        /* AddRoundKey */
        for (i = 0; i < 16; i++) s[i] ^= rkeys[r * 16 + i];

        /* InvMixColumns */
        for (i = 0; i < 4; i++) {
            uint8_t a = s[i*4], b = s[i*4+1], c = s[i*4+2], d = s[i*4+3];
            uint8_t xa = xtime(a), xb = xtime(b), xc = xtime(c), xd = xtime(d);
            uint8_t xa2 = xtime(xa), xb2 = xtime(xb), xc2 = xtime(xc), xd2 = xtime(xd);
            uint8_t xa3 = xtime(xa2), xb3 = xtime(xb2), xc3 = xtime(xc2), xd3 = xtime(xd2);
            s[i*4+0] = xa3^xa2^xa ^ xb3^xb ^ xc2^xc ^ xd3^xd;  /* 0e*a ^ 0b*b ^ 0d*c ^ 09*d */
            s[i*4+1] = xa3^xa ^ xb3^xb2^xb ^ xc3^xc ^ xd2^xd;
            s[i*4+2] = xa2^xa ^ xb3^xb ^ xc3^xc2^xc ^ xd3^xd;
            s[i*4+3] = xa3^xa ^ xb2^xb ^ xc3^xc ^ xd3^xd2^xd;
        }
    }

    /* Final round (no InvMixColumns) */
    uint8_t t;
    t = s[13]; s[13] = s[9]; s[9] = s[5]; s[5] = s[1]; s[1] = t;
    t = s[10]; s[10] = s[2]; s[2] = t;
    t = s[14]; s[14] = s[6]; s[6] = t;
    t = s[3]; s[3] = s[7]; s[7] = s[11]; s[11] = s[15]; s[15] = t;
    for (i = 0; i < 16; i++) s[i] = aes_inv_sbox[s[i]];
    for (i = 0; i < 16; i++) s[i] ^= rkeys[i];

    memcpy(out, s, 16);
}

/*
 * AES-128-CBC decrypt.
 * Returns plaintext length (after PKCS7 unpadding), or -1 on error.
 */
static int aes128_cbc_decrypt(const uint8_t *key, const uint8_t *iv,
                              const uint8_t *ct, size_t ct_len,
                              uint8_t *pt)
{
    uint8_t rkeys[176];
    uint8_t prev_ct[16];
    size_t i, j;

    if (ct_len % 16 != 0) return -1;

    aes128_key_expansion(key, rkeys);
    memcpy(prev_ct, iv, 16);

    for (i = 0; i < ct_len; i += 16) {
        uint8_t dec[16];
        aes128_decrypt_block(rkeys, ct + i, dec);
        for (j = 0; j < 16; j++)
            pt[i + j] = dec[j] ^ prev_ct[j];
        memcpy(prev_ct, ct + i, 16);
    }

    /* PKCS7 unpadding */
    if (ct_len > 0) {
        uint8_t pad = pt[ct_len - 1];
        if (pad >= 1 && pad <= 16) {
            int valid = 1;
            for (i = 0; i < pad; i++) {
                if (pt[ct_len - 1 - i] != pad) { valid = 0; break; }
            }
            if (valid)
                return (int)(ct_len - pad);
        }
    }
    return (int)ct_len;
}

static void show_usage(void)
{
    printf("Usage: decrypt_boardinfo -s <encrypted_file> -d <output_file>\n"
           "       decrypt_boardinfo -s <encrypted_file>   (output to stdout)\n"
           "\n"
           "Decrypts AES-128-CBC encrypted hw_boardinfo files.\n"
           "Uses the default Huawei boardinfo encryption key.\n");
}

int main(int argc, char **argv)
{
    const char *src = NULL, *dst = NULL;
    int c;

    while ((c = getopt(argc, argv, "s:d:h")) != -1) {
        switch (c) {
        case 's': src = optarg; break;
        case 'd': dst = optarg; break;
        case 'h': show_usage(); return 0;
        default:  show_usage(); return 1;
        }
    }

    if (!src) {
        show_usage();
        return 1;
    }

    /* Read encrypted file */
    FILE *fp = fopen(src, "rb");
    if (!fp) {
        fprintf(stderr, "Error: cannot open %s\n", src);
        return 1;
    }

    fseek(fp, 0, SEEK_END);
    long file_size = ftell(fp);
    fseek(fp, 0, SEEK_SET);

    if (file_size < 32) {
        fprintf(stderr, "Error: file too small\n");
        fclose(fp);
        return 1;
    }

    uint8_t *file_data = (uint8_t *)malloc((size_t)file_size);
    if (!file_data) { fclose(fp); return 1; }
    fread(file_data, 1, (size_t)file_size, fp);
    fclose(fp);

    /* Check if already plaintext (starts with "obj.") */
    if (file_size > 4 && memcmp(file_data, "obj.", 4) == 0) {
        fprintf(stderr, "File is already plaintext\n");
        if (dst) {
            FILE *out = fopen(dst, "wb");
            if (out) { fwrite(file_data, 1, (size_t)file_size, out); fclose(out); }
        } else {
            fwrite(file_data, 1, (size_t)file_size, stdout);
        }
        free(file_data);
        return 0;
    }

    /* Try decryption: first 16 bytes = IV, rest = ciphertext */
    uint8_t iv[16];
    memcpy(iv, file_data, 16);

    size_t ct_len = (size_t)(file_size - 16);
    uint8_t *pt = (uint8_t *)malloc(ct_len + 1);
    if (!pt) { free(file_data); return 1; }

    int pt_len = aes128_cbc_decrypt(default_key, iv, file_data + 16, ct_len, pt);

    if (pt_len <= 0) {
        /* Try with all-zero IV */
        memset(iv, 0, 16);
        pt_len = aes128_cbc_decrypt(default_key, iv, file_data, (size_t)file_size, pt);
    }

    if (pt_len > 0) {
        pt[pt_len] = '\0';

        /* Verify it looks like boardinfo text */
        if (strstr((char *)pt, "obj.") || strstr((char *)pt, "id =")) {
            if (dst) {
                FILE *out = fopen(dst, "wb");
                if (out) { fwrite(pt, 1, (size_t)pt_len, out); fclose(out); }
                printf("Decrypted %d bytes to %s\n", pt_len, dst);
            } else {
                fwrite(pt, 1, (size_t)pt_len, stdout);
            }
        } else {
            fprintf(stderr, "Warning: decrypted data doesn't look like boardinfo\n");
            if (dst) {
                FILE *out = fopen(dst, "wb");
                if (out) { fwrite(pt, 1, (size_t)pt_len, out); fclose(out); }
            } else {
                fwrite(pt, 1, (size_t)pt_len, stdout);
            }
        }
    } else {
        fprintf(stderr, "Error: decryption failed\n");
        free(pt);
        free(file_data);
        return 1;
    }

    free(pt);
    free(file_data);
    return 0;
}
